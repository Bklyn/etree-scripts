#!/usr/bin/perl -w
#
# shn2mp3 - Convert a directory of losslessly-compressed audio files
# (SHN or FLAC) into a directory of lossily-compressed audio files
# (MP3 or OGG) with useful tags.  Uses textfile parsing logic from the
# Etree::InfoFile module to parse info file stored with the SHN files
# to get information like the band name, venue, track names and
# recording source.
#
# Latest version is always available from:
#
# http://bklyn.org/~cae/shn2mp3
#
# $Id$

use strict;
use Getopt::Long;
use File::Basename;
use File::Find;
use Data::Dumper;
use POSIX qw(strftime);
use File::Copy;
use IO::Handle;
use Text::ParseWords;
use Cwd 'abs_path';
use lib dirname $0;
use Etree::InfoFile;

eval "use Date::Parse";
my $have_date_parse = not $@;

$File::Find::dont_use_nlink = 1; # Incase this is smbfs or whatever

my %BANDS;
(my $progname = basename $0) =~ s/\.pl$//;
my $version = '$Revision$ ';
$version =~ s/^.Revision:\s+//; $version =~ s/\s*\$\s*$//;
my $debug = 0;
my $writefiles = 0;
my $force = 0;
my $encoderopts = "";
my $bitrate = 192;
my $quality = 3;
my $preset;
my $altpreset = "standard";
my $target = ".";
my $test = 0;
my $help = 0;
my %OUTPUT;
my $rcfile = "$ENV{HOME}/.${progname}rc";
my $output_type = ($progname =~ /(ogg|mp3)$/ ? $1 : "mp3");

# ActiveState just can't get the job done.
die "ActiveState Perl not supported; install Cygwin (http://www.cygwin.com)\n"
  if $^O =~ /MSWin32/;

format STDOUT_TOP =
+-----------------------------------------------------------------------------+
|   Directory: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Directory"}
|   Info File: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"InfoFile"}
| Destination: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Destination"}
|        Band: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Band"} || "Unknown"
|        Date: @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Date"} || "Unknown"
|       Venue: ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Venue"}
| ~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Venue"}
| ~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Venue"}
|      Source: ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Source"}
| ~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Source"}
| ~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Source"}
| ~            ^<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< |
$OUTPUT{"Source"}
+-----------------------------------------------------------------------------+
 Track  Time  Title / Comments
------- ----- ----------------
.

format STDOUT =
@>>>>>> @>>>> @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
@OUTPUT{"Track", "Time", "Title"}
.

# Types of audio files we recognize, by extension
my @AUDIOEXT = ("shn", "mp3", "ogg", "flac");

# A regex that matches most dates
my $datefmt = '\d{4}[-\.\/]\d{1,2}[-\.\/]\d{1,2}|' .
  '\d{1,2}[-\.\/]\d{1,2}[-\.\/]\d{2,4}|' .
  '(?:jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\w*\s+\d{1,2}(?:st|nd|rd|th),?\s+\d{2,4}';

# extension - get the extension part of a filename
sub extension {
   my $filename = shift;
   my $ext = $filename;
   return if $ext =~ /(^(bak|orig)$|~$)/;
   $ext =~ s/^.+\.([^\.]+)$/$1/;
   $ext;
}

# shnlen - get the length of a SHN file in mm:ss.ff
sub shnlen {
   my $file = shift;
   my $length;

   open (SHNINFO, "shntool info \Q$file\E 2>/dev/null |") or return;

   while (<SHNINFO>) {
      if (/^length:\s+([\d\.:]+)/) {
	 $length = $1;
	 last;
      }
   }
   close SHNINFO;
   $length;
}

# parsetime - convert mm:ss.ff into seconds
sub parsetime {
   my $time = shift;
   my $seconds = 0;

   if (defined $time
       and $time =~ /^(\d+)[:\.\'](\d{2})\"?(?:[:\.](\d{2}))?$/) {
      $seconds = 60.0 * $1 + $2 + ($3 || 0) / 75.0;
   }

   $seconds;
}

# fmttime - convert seconds into m:ss.ff
sub fmttime {
   my $seconds = shift;
   my $time;

   if (defined $seconds) {
      my $min = int ($seconds / 60);
      my $sec = int ($seconds - 60 * $min);
      my $frames = 75 * ($seconds - $sec - 60 * $min);
      if ($frames) {
	 $time = sprintf ("%d:%02d.%02d", $min, $sec, $frames);
      } else {
	 $time = sprintf ("%d:%02d", $min, $sec);
      }
   }

   $time;
}

sub bytes_to_human {
   my %UNITS = (1 => "B",
                1024 => "kB",
                1024 ** 2 => "MB",
                1024 ** 3 => "GB",
                1024 ** 4 => "TB",
                1024 ** 5 => "PB");

   my $nbytes = shift;
   my $nunits;
   my $units;

   foreach my $divisor (sort { $a <=> $b } keys %UNITS) {
      last if $nbytes < $divisor;
      $units = $UNITS{$divisor};
      $nunits = $nbytes / $divisor;
   }

   $nbytes = $nunits ? sprintf ("%.1f %s", $nunits, $units) : $nbytes;

   $nbytes;
}

sub usage {
   $0 = basename $0;

   print <<EOF;
$0 - Convert SHN files into lossy-compressed \U$output_type\E files

Usage: $0 [options] path-to-shns

Options:
  --encoder-options "x" Additional arguments to pass to the \U$output_type\E encoder.
  -b | --bitrate b      Specify a constant bit-rate encoding instead of a VBR
                        preset.  This is also used when encoding OGG files.
                        Default is 192.
  -q | --quality q      Set oggenc encoding quality.  Worst is 0, best is 10.
                        Default is 3.
  --alt-preset p        Specify LAME encoder VBR alt-preset (deprecated, but
                        "standard" is the default).
  --preset p            Specify LAME encoder preset.  Overrides --alt-preset.
  --target t            Root directory where MP3s will be written.  Default is
                        the current working directory.
  --force               Force overwriting of existing MP3s.
  --test                Just print what would be done; do not encode anything.
  --mp3                 Generate MP3 output.  This is the default if the script
                        is invoked as "shn2mp3".
  --ogg                 Generate OGG output.  This is the default if the script
                        is invoked as "shn2ogg".
  --help                Generate this usage message and exit.
EOF
   ;
}

if (-f $rcfile and open (RCFILE, $rcfile)) {
   local $/ = 0;		# Slup the whole file
   unshift (@ARGV, shellwords (<RCFILE>));
   close RCFILE;
}

my $retval = GetOptions ("lameopts=s" => \$encoderopts,
			 "encoder-options=s" => \$encoderopts,
			 "b|bitrate=i" => sub { undef $preset;
						undef $altpreset;
						$bitrate = $_[1]; },
			 "alt-preset=s" => sub { undef $bitrate;
						 undef $preset;
						 $altpreset = $_[1]; },
			 "preset=s" => sub { undef $bitrate;
					     undef $altpreset;
					     $preset = $_[1]; },
			 "target=s" => \$target,
			 "test!" => \$test,
			 "q|quality=i" => \$quality,
			 "f|fast" => sub { $quality = "fast"; },
			 "h|high-quality" => sub { $quality = "high"; },
			 "force!" => \$force,
			 "debug!" => \$debug,
			 "help!" => sub { usage; exit (0); },
			 "mp3!" => sub { $output_type = "mp3"; },
			 "ogg!" => sub { $output_type = "ogg"; },
			 "version!" => sub { version(); exit (0); });

if ($retval == 0 or $help or not scalar @ARGV) {
   usage;
   exit (not $help);
}

my %DECODER = ( "shn" => "shorten -x %FILE% -",
		"flac" => "flac -d -s -c %FILE%",
		"mp3" => "mpg123 -q -s %FILE%",
		"ogg" => "oggdec -q -o - %FILE%");

my %ENCODER = ( "mp3" => ("lame " .
			  (defined $preset ?
			   "--preset %PRESET% " :
			   defined $altpreset ?
			   "--alt-preset %ALTPRESET% " :
			   "-b %BITRATE% -q %QUALITY% ") .
			  "--add-id3v2 --pad-id3v2 " .
			  "--ta %ARTIST% --tl %ALBUM% --tt %TITLE% " .
			  "--tc %COMMENT% --ty %YEAR% --tn %TRACK% " .
			  "%ENCODEROPTS% - %OUTFILE%" ),
		"ogg" => ("oggenc -b %BITRATE% -q %QUALITY% " .
			  "-a %ARTIST% -l %ALBUM% -t %TITLE% -N %TRACK% " .
			  "-c %COMMENT% -d %YEAR% " .
			  "-o %OUTFILE% %ENCODEROPTS% -")
	      );

sub version {
   my ($encoder, $rest) = split /\s/, $ENCODER{$output_type};
   my $encoderversion = `$encoder --version | head -1`;
   chomp $encoderversion;

   print <<EOF
$progname version $version using $encoderversion

Copyright 2002, Caleb Epstein

Copying and modification permitted only under the terms of the Perl
Artistic License, the text of which is available at <URL:
http://www.perl.com/language/misc/Artistic.html>

EOF
  ;
}

sub mkdir_p {
   my $dir = shift;
   my @D = split /\//, $dir;

   foreach my $i (0 .. $#D) {
      my $path = join ("/", @D[0..$i]);
      next unless length $path;
      if (not -d $path) {
	 mkdir ($path, 0777) or warn "mkdir $path: $!";
      }
   }
}

sub outputdir {
   my $dir = shift;
   my $outputdir = "$target/" . basename ($dir);
   $outputdir =~ s/(\.(shnf?|flac\d{0,2}f?|oggf?|mp3f?))?$/.${output_type}f/i;
   $outputdir;
}

sub lossless_to_lossy {
   my $info = shift;
   my $file = shift;
   my $song = shift;
   my $index = shift;

   my $shndir = $info->{"Directory"};
   my $outputdir = outputdir ($shndir);

   mkdir_p $outputdir unless $test or -d $outputdir;

   my $audioext = join ("|", @AUDIOEXT);
   my $outfile = "$outputdir/" . basename $file;
   $outfile =~ s/(\.wav)?\.($audioext)$/.$output_type/i;

   my $artist = $info->artist || "Unknown";
   my $album = $info->date || "Unknown";
   my ($disc, $track) = ($song->{Disc}, $song->{Track});
   $track = $index + 1;
   my $howmany = $info->num_tracks;
   my $n_of_m = sprintf (($howmany > 99 ? "%3d/%3d" : "%2d/%2d"), $index + 1,
			 $howmany);
   my $title = $song->{Title} || "";
   if (not length $title) {
      $title = sprintf (($howmany > 99
			 ? "Track %03d of %03d"
			 : "Track %02d of %02d"),
			$track, $howmany);
   }

   if ($howmany > 256 and defined $info->num_discs and $info->num_discs > 1) {
      $album .= " (Disc $disc of " . $info->num_discs . ")";
   }
   if ($info->venue) {
      $album .= " " . $info->venue;
   }
   my $year = substr ($info->date || "0000", 0, 4);
   my $comment = $info->source || "Encoded by $progname";
   my $tracktime = $song->{Time} || shnlen ($file) || "0:00";
   my $tracksecs = parsetime ($tracktime);

   my $input_type = extension ($file);

   if (not exists $DECODER{$input_type}) {
      warn "$progname: Don't know how to decode \U$input_type\E " .
	"input file $file\n";
      return 0;
   }

   my $decoder = $DECODER{$input_type};
   my $encoder = $ENCODER{$output_type};

   if ($quality eq "fast") {
      $quality = $output_type eq "mp3" ? 7 : 2;
   } elsif ($quality eq "high") {
      $quality = $output_type eq "mp3" ? 2 : 7;
   }

   $decoder =~ s/%FILE%/\Q$file\E/g;
   $encoder =~ s/%QUALITY%/$quality/g;
   $encoder =~ s/%BITRATE%/$bitrate/g if defined $bitrate;
   $encoder =~ s/%ALTPRESET%/$altpreset/g if defined $altpreset;
   $encoder =~ s/%PRESET%/$preset/g if defined $preset;
   $encoder =~ s/%ARTIST%/\Q$artist\E/g;
   $encoder =~ s/%ALBUM%/\Q$album\E/g;
   $encoder =~ s/%TITLE%/\Q$title\E/g;
   $encoder =~ s/%COMMENT%/\Q$comment\E/g;
   $encoder =~ s/%YEAR%/\Q$year\E/g;
   $encoder =~ s/%TRACK%/\Q$track\E/g;
   $encoder =~ s/%ENCODEROPTS%/$encoderopts/g;
   $encoder =~ s/%OUTFILE%/\Q$outfile\E/g;

   my $cmd = "$decoder | $encoder " . ($debug ? "" : " > /dev/null 2>&1");

   my $skip = (-f $outfile and -M $outfile < -M $file and not $force);

   @OUTPUT{"Destination", "Disc", "Track", "Time", "Title"} =
     ($outputdir, $disc, $track, $tracktime, $title);
   $OUTPUT{"Disc"} = "$disc/$info->{Discs}"
     if defined $info->{"Discs"} and $info->{"Discs"} > 1;
   $OUTPUT{"Track"} = "$track/$info->{Disc}{$disc}{Tracks}"
     if exists $info->{Disc} and exists $info->{Disc}{$disc};
   $OUTPUT{"Track"} = $n_of_m;
   $OUTPUT{"Time"} =~ s/\.\d+$//;
   $OUTPUT{"Venue"} ||= "Unknown";

   write;

   print "Command line: $cmd\n" if $debug;

   my $status = 0;
   my $start = time;

   if (not $test and not $skip) {
      $status = system ($cmd);
   }

   if ($status != 0) {
      unlink $outfile;		# Don't keep around a potentially short file

      my $signal = $status & 127;
      my $core = $status & 128;
      $status >>= 8;
      warn "Error encoding $file, exit status $status" .
	($signal ? " on signal $signal" : "") .
	  ($core ? " (dumped core)" : "") . "\n";

      if ($signal) {
	 print "Exiting.\n";
	 exit $signal;
      }
   } elsif (not $test) {
      my $finish = time;
      my $encodetime = $finish - $start;

      @OUTPUT{"Disc", "Track", "Time"} =
	("", "", $encodetime ? fmttime ($encodetime) : "");
      if ($tracksecs and $encodetime) {
	 $OUTPUT{"Title"} = "Encode speed " .
	   sprintf ("%.1fx", $tracksecs / $encodetime);
      } else {
	 $OUTPUT{"Title"} = "File size " . bytes_to_human (-s $outfile);
	 if ($skip) {
	    $OUTPUT{"Title"} .= ", created " .
	      strftime ("%m/%d/%y %H:%M", localtime ((stat $outfile)[10]));
	 }
      }
      write;
   }

   1;
}

foreach my $dir (@ARGV) {
   $dir = abs_path ($dir);	# Convert to an absolute path

   if (not -d $dir) {
      warn "$dir: not a directory\n";
      next;
   }

   my $info = new Etree::InfoFile (Directory => $dir) or die;

   $info->parse;

   print "Etree::InfoFile dump:\n", Dumper ($info), "\n" if $debug;

   %OUTPUT = %$info;
   $OUTPUT{"Source"} ||= "Unknown";

   $^L = "\n";
   STDOUT->format_lines_left (0);
   STDOUT->format_lines_per_page (99999);

   # Copy the info file
   if (not $test and exists $info->{"InfoFile"}) {
      my $source = $info->{"InfoFile"};
      my $dest = outputdir ($dir) . "/" . basename ($source);
      mkdir_p (outputdir ($dir));
      if (not -f $dest or -M $source < -M $dest or $force) {
	 copy ($source, $dest);
      }
   }

   # Encode the files
   my @FILES = ($info->files ("flac"), $info->files ("shn"));
   my @SONGS = $info->songs;

   if (scalar @FILES > scalar @SONGS) {
      print "Number of songs parsed from info file (" . scalar (@SONGS) .
	") does not match number of lossless audio files (" .
	  scalar (@FILES) . ").  Please correct the info file.\n";
      next;
   }

   foreach my $index (0 .. $#FILES) {
      lossless_to_lossy ($info, $FILES[$index], $SONGS[$index], $index)
	or die "Error converting $FILES[$index] to $output_type\n";
   }
}
