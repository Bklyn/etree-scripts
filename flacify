#!/usr/bin/perl -w
#
# flacify - Convert an etree-compliant directory of SHN (or FLAC)
# files into a well-tagged set of FLAC files.
#
# $Id$

use strict;
use File::Basename;
use File::Spec;
use lib dirname $0;
use Etree::InfoFile;		# Text file parsing classes
use Getopt::Long;
use File::Copy;
use Data::Dumper;
use File::Spec;
use Cwd;

my $progname = basename $0;
my $rcsid = q$Id$;
(my $version = q$Revision$) =~ s/^.Revision:\s+([\d\.]+)\s.+/$1/;
my $debug = 0;
my $dryrun = 0;
my $tagdiscs = 0;
my %EXES = ("unshn" => undef,
	    "flac" => undef,
	    "metaflac" => undef);

# On Windows, add the FLAC install dir to the PATH
if ($^O eq "MSWin32") {		# Active State
   $ENV{"PATH"} .= ';c:\Program Files\FLAC'
     if -d 'c:\Program Files\FLAC';
} elsif ($^O eq "cygwin") {	# Cygwin
   $ENV{"PATH"} .= ':/c/Program Files/FLAC'
     if -d '/c/Program Files/FLAC';
}

# Ensure all the binaries we need are in our PATH
foreach my $exe (keys %EXES) {
   $EXES{$exe} = findexe ($exe)
     or die "Can't find the required program `$exe' in your PATH\n";
}

# Line buffering
$| = 1;

GetOptions ("debug!" => \$debug,
	    "discs!" => \$tagdiscs,
	    "dry-run!" => \$dryrun,
	    "help!" => sub { use Pod::Usage;
			     pod2usage (-exitval => 0, -verbose => 1); },
	    "version!" => sub { print "$progname $rcsid\n"; exit (0); });

# findexe - find a binary in the PATH
sub findexe {
   my $exe = shift;
   my $fullpath;

   $fullpath = $exe if $exe =~ m@^/@ and -x $exe;

   if (not defined $fullpath) {
      my @PATH = File::Spec->path();
      foreach my $dir (@PATH) {
	 if (-x "$dir/$exe") {
	    $fullpath = "$dir/$exe";
	    last;
	 }
      }
   }

   $fullpath;
}

sub numeric { $a <=> $b }
sub setlist_order {
   if (not defined $a) {
      return defined $b ? 1 : 0;
   } elsif (not defined $b) {
      return defined $a ? -1 : 0;
   } elsif ($a =~ /^\d+$/ and $b =~ /^\d+$/) {
      return $a <=> $b;
   } elsif ($a eq "E") {
      return 1;
   } elsif ($b eq "E") {
      return -1;
   }
   return 0;
}

sub run_command {
   my @COMMAND = @_;

   $COMMAND[0] = $EXES{$COMMAND[0]};

   if ($dryrun) {
      print "DRYRUN: @COMMAND\n";
      return 0;
   }

   my $retval = system (@COMMAND);

   if ($retval != 0) {
      my $signal = $retval & 127;
      my $core = $retval & 128;
      my $status = $retval >> 8;

      warn "Error: $COMMAND[0] exited with status $status" .
	($signal ? " on signal $signal" : "") .
	  ($core ? " (dumped core)" : "") . "\n";

      return $status || $core || $signal;
   }

   0;
}

# convert_files - do the real work
sub convert_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;
   my $dir = $info->{Directory};

   chdir ($dir) or die "Couldn't change directory to $dir: $!\n";

   # 1. SHN -> WAV
   my @SHNS = grep { /\.shn$/i } @$files;

   if (scalar @SHNS) {
      print "Extracting SHN to WAV\n";

      my $status = run_command ("unshn", @SHNS);

      die "Error unpacking SHN files\n" unless $status == 0 or $status == 2;
   }

   # 2. WAV -> FLAC
   my @WAVS = map {
      # WAV file will be created in ouur CWD
      (my $file = basename $_) =~ s/\.shn$/.wav/i;
      die "WAV file $file missing\n"
	unless -f $file or $dryrun;
      $file } @SHNS;

   # Also add in any WAV files from the start
   push (@WAVS, grep { /\.wav$/i } @$files);

   if (scalar @WAVS) {
      print "Converting WAV files to FLAC\n";

      # In order to do proper CD sector alignment, we want to group files
      # by set
      my %GROUPS;
      my $groupby = "Set";

      map { if (defined) {
	 my $set = $_->{Set} || 0;
	 $GROUPS{$set}->{$_->{Index}} = $_; } } @$songs;

      # If we dopn't have any set info, group files by disc instead
      if (scalar keys %GROUPS <= 1 and exists $GROUPS{0}) {
	 print "No set information.  Grouping by disc.\n";
	 undef %GROUPS;
	 $groupby = "Disc";
	 foreach my $disc (1 .. $info->num_discs) {
	    map { $GROUPS{$disc}{$_->{Index}} = $_ }
	      grep { defined and $_->{Disc} == $disc } @$songs;
	 }
      }

      if (not scalar keys %GROUPS) {
	 $groupby = "Files";
	 map { $GROUPS{1}{$_} = undef; } 0 .. $#$files;
      }

      print "Groups (by $groupby):\n", Dumper (\%GROUPS) if $debug;

      # Reverse the mapping from group -> files to file -> group
      my %INDEX_GROUP;

      foreach my $group (keys %GROUPS) {
	 # Get the list of file indexes
	 my @BATCH = keys %{$GROUPS{$group}};
	 # Map from index -> group
	 map { $INDEX_GROUP{$_} = $group } @BATCH;
      }

      foreach my $group (sort setlist_order keys (%GROUPS)) {
	 my @BATCH = sort numeric keys %{$GROUPS{$group}};
	 my @FILES = map { $WAVS[$_] } grep { $_ <= $#WAVS  } @BATCH;

	 next unless scalar @FILES;

	 print "Converting $groupby $group from WAV to FLAC, ",
	   scalar (@FILES), " files:\n\t",
	     join ("\n\t", map { basename $_ } @FILES), "\n\n";

	 # Compress the WAV files to FLAC files, deleting as we go.
	 # Ensure CD sector alignment
	 my $status = run_command ("flac",
				   "--sector-align",
				   "--delete-input-file",
				   "--replay-gain",
				   @FILES);

	 if ($status != 0) {
	    # Remove any FLACs we created
	    foreach my $file (@FILES) {
	       (my $flac = $file) =~ s/\.wav$/.flac/i;
	       unlink $flac if -e $flac;
	    }
	    die "Error encoding FLAC files\n";
	 }
      }
   }

   # 3. Tag FLAC files
   my @FLACS = grep { /\.flac$/i } @$files;

   push (@FLACS, map {
      (my $file = basename $_) =~ s/\.wav$/.flac/i;
      die "FLAC file $file missing\n" unless -f $file or $dryrun;
      die "FLAC file $file empty (disk full?)\n"
	unless -s $file or $dryrun;
      $file } @WAVS);

   @FLACS = sort { basename ($a) cmp basename ($b) } @FLACS;

   die "Number of FLAC files (" . scalar (@FLACS) . ") does not match " .
     "number of songs (" . scalar (@$songs) . ")\n"
       unless scalar @FLACS == scalar @$songs;

   print "Tagging files:\n";

   tag_files ($info, $songs, \@FLACS) or die "Error tagging files\n";

   # 4. Move files to $info->{Directory}
   foreach my $file (@FLACS) {
      my $absfile = File::Spec->rel2abs ($file);

      if (dirname ($absfile) ne $dir) {
	 my $moveto = "$dir/" . basename $file;
	 print "Moving $file -> $moveto: ";
	 if (not $dryrun) {
	    move ($file, $moveto) or die "Error moving $file to $dir: $!\n";
	 }
	 print "OK\n";
      }
   }

   print "Removing original SHN files\n" if scalar @SHNS;

   my $howmany = ($dryrun ? scalar (@SHNS) : unlink (@SHNS));

   if ($howmany != scalar @SHNS) {
      die "Removed only $howmany SHN files, expected " .
	scalar (@SHNS) . "\n";
   }

   (my $newdir = $dir) =~ s/\.(shn|flac\d*)f?$//ig; $newdir .= ".flac16";

   if (not $dryrun and $newdir ne $dir) {
      print "Renaming $dir -> $newdir\n";
      rename ($dir, $newdir) or die "Rename failed: $!\n";
   }

   1;
}

sub tag_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;

   # FLAC tags taken from
   # http://reactor-core.org/ogg-tag-recommendations.html
   my %TAGS;

   $TAGS{"ARTIST"} = $info->artist if $info->artist;
   $TAGS{"ALBUM"} = $info->album if $info->album;
   $TAGS{"DATE"} = $info->date if $info->date;
   $TAGS{"LOCATION"} = $info->venue if $info->venue;
   $TAGS{"SOURCEMEDIA"} = $info->source if $info->source;

   foreach my $index (0 .. $#$files) {
      my $song = ref ($songs) ? $songs->[$index] : undef;
      delete $TAGS{"DISCNUMBER"};
      delete $TAGS{"TRACKNUMBER"};
      delete $TAGS{"TITLE"};
      delete $TAGS{"COMMENT"};

      # If running in --discs mode, tag files with DISCNUMBER and
      # TRACKNUMBER.  Not all applications/devices honor the
      # DISCNUMBER tag though, so this may leave you with all of your
      # Track 1's sorting before all of your Track 2's.
      if (defined $song and $tagdiscs) {
	 $TAGS{"DISCNUMBER"} = $song->{Disc} if $song->{Disc};
	 $TAGS{"TRACKNUMBER"} = $song->{Track} || ($index + 1);
      } else {
	 $TAGS{"DISCNUMBER"} = undef;
	 $TAGS{"TRACKNUMBER"} = $index + 1;
      }

      $TAGS{"TITLE"} = $song->{Title} if defined $song and $song->{Title};

      my $note;
      $note = $song->{Notes} if defined $song and exists $song->{Notes};

      if (defined $note and exists $info->{Notes}{$note}) {
	 $TAGS{"COMMENT"} = $info->{Notes}{$note};
      }

      print "" . sprintf ("%2d/%2d", $index + 1, $#$files + 1) . ": " .
	($TAGS{TITLE} || "") .
	  (exists $TAGS{COMMENT} ? " ($TAGS{COMMENT})" : "") . "\n";

      my @TAGS;
      foreach my $tag (keys %TAGS) {
	 push (@TAGS, "--remove-vc-field=$tag");
	 push (@TAGS, "--set-vc-field=$tag=$TAGS{$tag}")
	   if defined $TAGS{$tag};
      }
      my @CMD = ("metaflac", @TAGS, $files->[$index]);

      my $status = run_command (@CMD);

      if ($status != 0) {
	 warn "Error setting tags on $files->[$index]\n";
	 return 0;
      }
   }

   1;
}

# Operate on CWD if nothing is specified
if (not scalar @ARGV) { push (@ARGV, "."); }

foreach my $dir (map { File::Spec->rel2abs ($_) } @ARGV) {
   if (not -d $dir) {
      warn "$dir: not a directory\n";
      next;
   }

   my $info = new Etree::InfoFile (Directory => $dir) or die;

   $info->parse;

   print "Processing directory $dir:\n";

   print "Etree::InfoFile dump:\n" . Dumper ($info) if $debug;

   print "Artist: ", $info->artist || "Unknown", "\n",
     "  Date: ", $info->date || "Unknown", "\n",
       " Venue: ", $info->venue || "Unknown", "\n",
	 "Source: ", $info->source || "Unknown", "\n\n";

   # Get the list of all possible audio files we will convert
   my @FILES = sort { $a cmp $b } $info->files ("flac"),
     $info->files ("wav"), $info->files ("shn");

   if (not scalar @FILES) {
      print "No appropriate audio files found\n";
      next;
   }

   my @SONGS = $info->songs;

   if (scalar @SONGS and scalar @SONGS < scalar @FILES) {
      print "Number of songs from info file (" . scalar (@SONGS) .
	") doesn't match number of audio files (" . scalar (@FILES) . "):\n";
      print "Songs: ", join (", ", map { $_->{Title} } @SONGS), "\n",
	"Files: ", join (", ", map { basename $_ } @FILES), "\n";
      next;
   }

   print "Songs:\n", Dumper (\@SONGS) if $debug;

   # Truncate the song list to match the file list
   $#SONGS = $#FILES;

   convert_files ($info, \@SONGS, \@FILES) or die "Error converting files\n";
}

__END__

=head1 NAME

flacify - Convert audio files to FLAC files with Vorbis comments

=head1 SYNOPSIS

flacify [options] directory [directory ...]

=head1 OPTIONS

=over 8

=item B<--help>

Generate this usage message and exit.

=item B<--version>

Print version information and exit.

=item B<--debug>

Turn on debugging mode.  Dumps copious output useful mostly to the
maintainer.

=item B<--discs>

Keep tracks grouped by discs and use the Ogg Vorbis DISCNUMBER comment
field to distinguish one disc from another.  Some players do not honor
this tag and so will sort track 1 of each disc before track 2 of any
disc (e.g. playback might run D1T1, D2T1, D1T2, ...).  The default is
to number tracks sequentially from 1 to I<n> with no regard to any
disc groups.

=item B<--dry-run>

Print what commands would be run, but don't run them.

=back

=head1 DESCRIPTION

The purpose of L<flacify> is to convert audio files from WAVE, Shorten
or FLAC format into losslessly-compressed, B<tagged> FLAC files.  The
code is geared towards processing live concert recordings arranged
according to the standards of L<http://etree.org/>.  The audio files
must be accompanied by a text file which provides detailed
information about the artist, date, venue and track list of the
recording.

For each directory the user specifies, L<flacify> performs the
following steps:

=over

=item Parsing

The directory is processed by the the L<Etree::InfoFile> module, which
searches for audio files and text files in the directory.  Text files
are parsed for the name of the artist, venue, date, song names,
recording source, and other information.  These will be used in the
tagging process.

If no text files can be found, an error is emitted and the directory is
not processed.

If the input files are all FLAC files, we skip ahead to the
L<"Tagging"> step.

=item Decompression

Uncompressing any SHN files to WAV files using the L<unshn> script,
also from the etree-script distribution.  If the input consists of
only WAV files, this step is skipped.  FLAC files are not
decompressed either.

At the end of this step we are left will all WAV or FLAC files.

=item Compression

Any WAV files resulting from the previous step are then compressed
using the command line L<flac> encoder.  The following options are
passed to L<flac>: --sector-align --delete-input-file --replay-gain.

=item Tagging

We are now left with all FLAC files.  These are tagged with the
information from the L<"Parsing"> step.  The tagging uses these fields
as specified by L<http://www.xiph.org/ogg/vorbis/doc/v-comment.html>:

=over

=item ARTIST

The performer.  Usually taken from the first line of the info file.

=item ALBUM

The date of the performance in YYYY-MM-DD format followed by the venue
information (e.g. "2003-01-01 Lupo's Hearbreak Hotel - Providence,
RI")

=item DATE

The date of the performance in YYYY-MM-DD format.

=item LOCATION

The venue where the performance happened.

=item SOURCEMEDIA

The recording source information, if this was found.  Usually contains
microphone, A/D converter, and recorder information.

=item DISCNUMBER

When run with B<--discs>, this tag will be set for each file.
Otherwise it will not be set.

=item TRACKNUMBER

The number of each track in the set.  When run with B<--discs>, the
TRACKNUMBER will be the number of the track within its disc, otherwise
it will be the number of the track in the entire set.

=item TITLE

The name of the song.

=item COMMENT

If there are any notes found for a given song, they will be included
in this tag.

=back

=item Directory Renaming

Finally, the directory is renamed to end in ".flac16".  If the
directory name previously ended in ".shn" or ".shnf", that suffix is
removed.

=back

=head1 VERSION

$Id$

=head1 SEE ALSO

L<unshn>, L<shorten>, L<flac>, L<metaflac>, L<Etree::InfoFile>

=head1 AUTHOR

Caleb Epstein E<lt>cae at bklyn dot orgE<gt>
