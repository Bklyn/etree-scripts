#!/usr/bin/perl -w
#
# flacify - Convert an etree-compliant directory of SHN (or FLAC)
# files into a well-tagged set of FLAC files.
#
# $Id$

use strict;
use File::Basename;
use File::Spec;
use lib dirname $0;
use Etree::InfoFile;		# Text file parsing classes
use Getopt::Long;
use File::Copy;
use Data::Dumper;
use File::Spec;

my $progname = basename $0;
(my $version = q$Revision$) =~ s/^.Revision:\s+([\d\.]+)\s.+/$1/;
my $debug = 0;
my $dryrun = 0;
my $tagdiscs = 0;
my %EXES = ("unshn" => undef,
	    "flac" => undef,
	    "metaflac" => undef);

# Ensure all the binaries we need are in our PATH
foreach my $exe (keys %EXES) {
   $EXES{$exe} = findexe ($exe)
     or die "Can't find the required program `$exe' in your PATH\n";
}

# Line buffering
$| = 1;

sub usage {
   print <<EOF
$progname - Convert audio files to FLAC files with tags

Usage: $progname [options] directory [directory ...]

Options:
  --debug     Print extra debugging info.
  --discs     Number tracks per-disc.  May not sort properly on some players.
  --dry-run   Print what would be done, but don't actually do it.
  --version   Print version information and exit
  --help      Print this usage message and exit
EOF
;
}

GetOptions ("debug!" => \$debug,
	    "discs!" => \$tagdiscs,
	    "dry-run!" => \$dryrun,
	    "help!" => sub { usage; exit 0; },
	    "version!" => sub { print "$progname " .
				  q$Id$ . "\n";
				exit 0; } );

# findexe - find a binary in the PATH
sub findexe {
   my $exe = shift;
   my $fullpath;

   $fullpath = $exe if $exe =~ m@^/@ and -x $exe;

   if (not defined $fullpath) {
      my @PATH = File::Spec->path();
      foreach my $dir (@PATH) {
	 if (-x "$dir/$exe") {
	    $fullpath = "$dir/$exe";
	    last;
	 }
      }
   }

   $fullpath;
}

sub numeric { $a <=> $b }

sub setlist_order {
   if (not defined $a) {
      return defined $b ? 1 : 0;
   } elsif (not defined $b) {
      return defined $a ? -1 : 0;
   } elsif ($a =~ /^\d+$/ and $b =~ /^\d+$/) {
      return $a <=> $b;
   } elsif ($a eq "E") {
      return 1;
   } elsif ($b eq "E") {
      return -1;
   }
   return 0;
}

sub run_command {
   my @COMMAND = @_;

   $COMMAND[0] = $EXES{$COMMAND[0]};

   if ($dryrun) {
      print "DRYRUN: @COMMAND\n";
      return 0;
   }

   my $retval = system (@COMMAND);

   if ($retval != 0) {
      my $signal = $retval & 127;
      my $core = $retval & 128;
      my $status = $retval >> 8;

      warn "Error: $COMMAND[0] exited with status $status" .
	($signal ? " on signal $signal" : "") .
	  ($core ? " (dumped core)" : "") . "\n";

      return $status || $core || $signal;
   }

   0;
}

# convert_files - do the real work
sub convert_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;

   # 1. SHN -> WAV
   my @SHNS = grep { /\.shn$/i } @$files;

   if (scalar @SHNS) {
      print "Extracting SHN to WAV\n";

      my $status = run_command ("unshn", @SHNS);

      die "Error unpacking SHN files\n" unless $status == 0 or $status == 2;
   }

   # 2. WAV -> FLAC
   my @WAVS = map {
      # WAV file will be created in ouur CWD
      (my $file = basename $_) =~ s/\.shn$/.wav/i;
      die "WAV file $file missing\n"
	unless -f $file or $dryrun;
      $file } @SHNS;

   # Perhaps we are starting with WAV Files
   if (not scalar @WAVS) {
      @WAVS = grep { /\.wav$/i } @$files;
   }

   if (scalar @WAVS) {
      print "Converting WAV files to FLAC\n";

      # In order to do proper CD sector alignment, we want to group files
      # by set
      my %GROUPS;
      my $groupby = "Set";

      map { my $set = $_->{Set} || 0;
	    $GROUPS{$set}->{$_->{Index}} = $_; } @$songs;

      # If we dopn't have any set info, group files by disc instead
      if (scalar keys %GROUPS == 1 and exists $GROUPS{0}) {
	 print "No set information.  Grouping by disc.\n";
	 undef %GROUPS;
	 $groupby = "Disc";
	 foreach my $disc (1 .. $info->num_discs) {
	    map { $GROUPS{$disc}{$_->{Index}} = $_ }
	      grep { $_->{Disc} == $disc } @$songs;
	 }
      }

      print "Groups:\n", Dumper (\%GROUPS) if $debug;

      # Reverse the mapping from group -> files to file -> group
      my %INDEX_GROUP;

      foreach my $group (keys %GROUPS) {
	 # Get the list of file indexes
	 my @BATCH = keys %{$GROUPS{$group}};
	 # Map from index -> group
	 map { $INDEX_GROUP{$_} = $group } @BATCH;
      }

      # Ensure that the number of file indexes in the %INDEX_GROUP hash
      # matches the total number of files to process
      if (scalar keys %INDEX_GROUP != scalar @WAVS) {
	 die "Logic Error: file batching created " .
	   scalar (keys %GROUPS) . " file groups " .
	     "comprising " . scalar (keys %INDEX_GROUP) .
	       " files, but there are " . scalar (@WAVS) .
		 " files to process\n";
      }

      foreach my $group (sort setlist_order keys (%GROUPS)) {
	 my @BATCH = sort numeric keys %{$GROUPS{$group}};
	 my @FILES = map { $WAVS[$_] } @BATCH;

	 print "Converting $groupby $group from WAV to FLAC, ",
	   scalar (@FILES), " files:\n\t",
	     join ("\n\t", map { basename $_ } @FILES), "\n\n";

	 # Compress the WAV files to FLAC files, deleting as we go.
	 # Ensure CD sector alignment
	 my $status = run_command ("flac",
				   "--sector-align",
				   "--delete-input-file",
				   "--replay-gain",
				   @FILES);

	 if ($status != 0) {
	    # Remove any FLACs we created
	    foreach my $file (@FILES) {
	       (my $flac = $file) =~ s/\.wav$/.flac/i;
	       unlink $flac if -e $flac;
	    }
	    die "Error encoding FLAC files\n";
	 }
      }
   }

   # 3. Tag FLAC files
   my @FLACS = grep { /\.flac$/i } @$files;

   push (@FLACS, map {
      (my $file = basename $_) =~ s/\.wav$/.flac/i;
      die "FLAC file $file missing\n" unless -f $file or $dryrun;
      die "FLAC file $file empty (disk full?)\n"
	unless -s $file or $dryrun;
      $file } @WAVS);

   die "Number of FLAC files (" . scalar (@FLACS) . ") does not match " .
     "number of songs (" . scalar (@$songs) . ")\n"
       unless scalar @FLACS == scalar @$songs;

   print "Tagging files\n";

   tag_files ($info, $songs, \@FLACS) or die "Error tagging files\n";

   # 4. Move files to $info->{Directory}
   my $dir = File::Spec->rel2abs ($info->{Directory});

   foreach my $file (@FLACS) {
      my $absfile = File::Spec->rel2abs ($file);

      if (dirname ($absfile) ne $dir) {
	 my $moveto = "$dir/" . basename $file;
	 print "Moving $file -> $moveto: ";
	 if (not $dryrun) {
	    move ($file, $moveto) or die "Error moving $file to $dir: $!\n";
	 }
	 print "OK\n";
      }
   }

   print "Removing original SHN files\n" if scalar @SHNS;

   my $howmany = ($dryrun ? scalar (@SHNS) : unlink (@SHNS));

   if ($howmany != scalar @SHNS) {
      die "Removed only $howmany SHN files, expected " .
	scalar (@SHNS) . "\n";
   }

   (my $newdir = $dir) =~ s/\.(shn|flac\d*)f?$//ig; $newdir .= ".flac16";

   if (not $dryrun and $newdir ne $dir) {
      print "Renaming $dir -> $newdir\n";
      rename ($dir, $newdir) or die "Rename failed: $!\n";
   }

   1;
}

sub tag_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;

   # FLAC tags taken from
   # http://reactor-core.org/ogg-tag-recommendations.html
   my %TAGS;

   $TAGS{"ARTIST"} = $info->artist if $info->artist;
   $TAGS{"ALBUM"} = $info->album if $info->album;
   $TAGS{"DATE"} = $info->date if $info->date;
   $TAGS{"LOCATION"} = $info->venue if $info->venue;
   $TAGS{"SOURCEMEDIA"} = $info->source if $info->source;

   foreach my $index (0 .. $#$songs) {
      my $song = $songs->[$index];
      delete $TAGS{"DISCNUMBER"};
      delete $TAGS{"TRACKNUMBER"};
      delete $TAGS{"TITLE"};
      delete $TAGS{"COMMENT"};

      if ($tagdiscs) {
	 $TAGS{"DISCNUMBER"} = $song->{Disc} if $song->{Disc};
	 $TAGS{"TRACKNUMBER"} = $song->{Track} || ($index + 1);
      } else {
	 $TAGS{"DISCNUMBER"} = undef;
	 $TAGS{"TRACKNUMBER"} = $index + 1;
      }

      $TAGS{"TITLE"} = $song->{Title} if $song->{Title};

      my $note = $song->{Notes};

      if (defined $note and exists $info->{Notes}{$note}) {
	 $TAGS{"COMMENT"} = $info->{Notes}{$note};
      }

      print basename ($files->[$index]) . ": " . ($TAGS{TITLE} || "") . "\n";

      my @TAGS;
      foreach my $tag (keys %TAGS) {
	 push (@TAGS, "--remove-vc-field=$tag");
	 push (@TAGS, "--set-vc-field=$tag=$TAGS{$tag}")
	   if defined $TAGS{$tag};
      }
      my @CMD = ("metaflac", @TAGS, $files->[$index]);

      my $status = run_command (@CMD);

      if ($status != 0) {
	 warn "Error setting tags on $files->[$index]\n";
	 return 0;
      }
   }

   1;
}

foreach my $dir (@ARGV) {
   if (not -d $dir) {
      warn "$dir: not a directory\n";
      next;
   }

   my $info = new Etree::InfoFile (Directory => $dir) or die;

   $info->parse;

   print "Processing directory $dir:\n";

   print "Etree::InfoFile dump:\n" . Dumper ($info) if $debug;

   print "Artist: ", $info->artist || "Unknown", "\n",
     "  Date: ", $info->date || "Unknown", "\n", 
       " Venue: ", $info->venue || "Unknown", "\n",
	 "Source: ", $info->source || "Unknown", "\n\n";

   # Get the list of all possible audio files we will convert
   my @FILES = sort { $a cmp $b } $info->files ("flac"),
     $info->files ("wav"), $info->files ("shn");

   if (not scalar @FILES) {
      print "No appropriate audio files found\n";
      next;
   }

   my @SONGS = $info->songs;

   if (scalar @SONGS < scalar @FILES) {
      print "Number of songs from info file (" . scalar (@SONGS) .
	") doesn't match number of audio files (" . scalar (@FILES) . "):\n";
      print "Songs: ", join (", ", map { $_->{Title} } @SONGS), "\n",
	"Files: ", join (", ", map { basename $_ } @FILES), "\n";
      next;
   }

   print "Songs:\n", Dumper (\@SONGS) if $debug;

   # Truncate the song list to match the file list
   $#SONGS = $#FILES;

   convert_files ($info, \@SONGS, \@FILES) or die "Error converting files\n";
}
