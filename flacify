#!/usr/bin/perl -w
#
# flacify - Convert an etree-compliant directory of SHN (or FLAC)
# files into a well-tagged set of FLAC files.
#
# $Id$

use strict;
use File::Basename;
use File::Spec;
use File::Find;
use lib dirname $0;
use Etree::InfoFile;		# Text file parsing classes
use Getopt::Long;
use File::Copy;
use Data::Dumper;
use File::Spec;
use Cwd;
use Carp;

my $progname = basename $0;
my $rcsid = q$Id$;
(my $version = q$Revision$) =~ s/^Revision:\s+([\d\.]+)\s.*/$1/;
my $debug = 0;
my $dryrun = 0;
my $tagdiscs = 0;
my $replay_gain = 1;

my %EXES = ("unshn" => undef,
	    "flac" => undef,
	    "metaflac" => undef);

my %TAGFORMAT = ("ARTIST" => "ARTIST",
		 "ALBUM" => "ALBUM",
		 "DATE" => "DATE",
		 "LOCATION" => "LOCATION",
		 "SOURCEMEDIA" => "SOURCEMEDIA",
		 "DISCNUMBER" => "DISCNUMBER",
		 "TRACKNUMBER" => "TRACKNUMBER",
		 "TITLE" => "TITLE",
		 "COMMENT" => "COMMENT");

# On Windows, add the FLAC install dir to the PATH
if ($^O eq "MSWin32") {		# Active State
   $ENV{"PATH"} .= ';c:\Program Files\FLAC'
     if -d 'c:\Program Files\FLAC';
} elsif ($^O eq "cygwin") {	# Cygwin
   $ENV{"PATH"} .= ':/c/Program Files/FLAC'
     if -d '/c/Program Files/FLAC';
}

# Ensure all the binaries we need are in our PATH
foreach my $exe (keys %EXES) {
   $EXES{$exe} = findexe ($exe)
     or die "Can't find the required program `$exe' in your PATH\n";
}

# Line buffering
$| = 1;

GetOptions ("debug!" => \$debug,
	    "discs!" => \$tagdiscs,
	    "dry-run!" => \$dryrun,
	    "help!" => sub { exit system ("perldoc", $0) },
	    "version!" => sub { version (); exit (0) },
	    "replay-gain!" => \$replay_gain,
	    "tag=s%" => \%TAGFORMAT);

# version - print version info
sub version {
   my $flacver = `$EXES{flac} --version`;
   chomp $flacver;

   print <<EOF
$progname version $version using $flacver

Copyright 2005, Caleb Epstein

Copying and modification permitted only under the terms of the Perl
Artistic License, the text of which is available at <URL:
http://www.perl.com/language/misc/Artistic.html>

EOF
  ;
}

# findexe - find a binary in the PATH
sub findexe {
   my $exe = shift;
   my $fullpath;

   $fullpath = $exe if $exe =~ m@^/@ and -x $exe;

   if (not defined $fullpath) {
      my @PATH = File::Spec->path();
      foreach my $dir (@PATH) {
	 if (-x "$dir/$exe") {
	    $fullpath = "$dir/$exe";
	    last;
	 }
      }
   }

   $fullpath;
}

# Sort helpers
sub numeric { $a <=> $b }

sub setlist_order {
   if (not defined $a) {
      return defined $b ? 1 : 0;
   } elsif (not defined $b) {
      return defined $a ? -1 : 0;
   } elsif ($a =~ /^\d+$/ and $b =~ /^\d+$/) {
      return $a <=> $b;
   } elsif ($a eq "E") {
      return 1;
   } elsif ($b eq "E") {
      return -1;
   }
   return 0;
}

sub run_command {
   my @COMMAND = @_;

   $COMMAND[0] = $EXES{$COMMAND[0]};

   if ($dryrun) {
      print "DRYRUN: " . join (" ",
			       map { $_ =~ m/[\s[:punct:]]/ ? "'$_'" : $_ }
			       @COMMAND) . "\n";
      return 0;
   }

   my $retval = system (@COMMAND);

   if ($retval != 0) {
      my $signal = $retval & 127;
      my $core = $retval & 128;
      my $status = $retval >> 8;

      warn "Error: $COMMAND[0] exited with status $status" .
	($signal ? " on signal $signal" : "") .
	  ($core ? " (dumped core)" : "") . "\n";

      return $status || $core || $signal;
   }

   0;
}

# convert_files - do the real work
sub convert_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;
   my $dir = $info->{Directory};

   chdir ($dir) or die "Couldn't change directory to $dir: $!\n";

   # 1. SHN -> WAV
   my @SHNS = grep { /\.shn$/i } @$files;

   if (scalar @SHNS) {
      print "Extracting SHN to WAV\n";

      my $status = run_command ("unshn", @SHNS);

      die "Error unpacking SHN files\n" unless $status == 0 or $status == 2;
   }

   print "SHN files: @SHNS\n" if $debug;

   # 2. WAV -> FLAC
   my @WAVS = map {
      # WAV file will be created in ouur CWD
      (my $file = basename $_) =~ s/\.shn$/.wav/i;
      die "WAV file $file missing\n"
	unless -f $file or $dryrun;
      $file } @SHNS;

   # Also add in any WAV files from the start
   push (@WAVS, grep { /\.wav$/i } @$files);

   print "WAV files: @WAVS\n" if $debug;

   if (scalar @WAVS) {
      print "Converting WAV files to FLAC\n";

      # In order to do proper CD sector alignment, we want to group files
      # by set
      my %GROUPS;
      my $groupby = "Set";

      map {
	 my $set = $_->{Set} || 0;
	 $GROUPS{$set}->{$_->{Index}} = $_;
      } @$songs;

      # If we dopn't have any set info, group files by disc instead
      if (scalar keys %GROUPS <= 1 and exists $GROUPS{0}) {
	 print "No set information.  Grouping by disc.\n";
	 undef %GROUPS;
	 $groupby = "Disc";
	 foreach my $disc (1 .. $info->num_discs) {
	    map { $GROUPS{$disc}{$_->{Index}} = $_ }
	      grep { defined and $_->{Disc} == $disc } @$songs;
	 }
      }

      if (not scalar keys %GROUPS) {
	 $groupby = "Files";
	 map { $GROUPS{1}{$_} = undef; } 0 .. $#$files;
      }

      print "Groups (by $groupby):\n", Dumper (\%GROUPS) if $debug;

      # Reverse the mapping from group -> files to file -> group
      my %INDEX_GROUP;

      foreach my $group (keys %GROUPS) {
	 # Get the list of file indexes
	 my @BATCH = keys %{$GROUPS{$group}};
	 # Map from index -> group
	 map { $INDEX_GROUP{$_} = $group } @BATCH;
      }

      print "Index groups:\n", Dumper (\%INDEX_GROUP) if $debug;

      foreach my $group (sort setlist_order keys (%GROUPS)) {
	 my @BATCH = sort numeric keys %{$GROUPS{$group}};

	 print "Batch $group: @BATCH\n" if $debug;

	 my @FILES = map { $WAVS[$_] } grep { $_ <= $#WAVS } @BATCH;

	 print "Files for batch $group: @FILES\n" if $debug;

	 next unless scalar @FILES;

	 print "Converting $groupby $group from WAV to FLAC, ",
	   scalar (@FILES), " files:\n\t",
	     join ("\n\t", map { basename $_ } @FILES), "\n\n";

	 # Compress the WAV files to FLAC files, deleting as we go.
	 # Ensure CD sector alignment
	 my @CMD = ("flac", "--sector-align", "--delete-input-file");

	 if ($replay_gain) {
	    push (@CMD, "--replay-gain");
	 }

	 my $status = run_command (@CMD, @FILES);

	 if ($status != 0) {
	    # Remove any FLACs we created
	    foreach my $file (@FILES) {
	       (my $flac = $file) =~ s/\.wav$/.flac/i;
	       unlink $flac if -e $flac;
	    }
	    die "Error encoding FLAC files\n";
	 }
      }
   }

   # 3. Tag FLAC files
   my @FLACS = grep { /\.flac$/i } @$files;

   push (@FLACS, map {
      (my $file = basename $_) =~ s/\.wav$/.flac/i;
      die "FLAC file $file missing\n" unless -f $file or $dryrun;
      die "FLAC file $file empty (disk full?)\n"
	unless -s $file or $dryrun;
      $file } @WAVS);

   @FLACS = sort { basename ($a) cmp basename ($b) } @FLACS;

   die "Number of FLAC files (" . scalar (@FLACS) . ") does not match " .
     "number of songs (" . scalar (@$songs) . ")\n"
       unless scalar @FLACS == scalar @$songs;

   print "Tagging files:\n";

   tag_files ($info, $songs, \@FLACS) or die "Error tagging files\n";

   # If we have pre-existing FLAC files, make sure they have Replay
   # Gain tags
   if ($replay_gain and not scalar @SHNS) {
      replay_gain (@FLACS) or die "Error calculating ReplayGain\n";
   }

   print "Removing original SHN files\n" if scalar @SHNS;

   my $howmany = ($dryrun ? scalar (@SHNS) : unlink (@SHNS));

   if ($howmany != scalar @SHNS) {
      die "Removed only $howmany SHN files, expected " .
	scalar (@SHNS) . "\n";
   }

   # Create FLAC fingerprint file
   if (not $dryrun and not -e "$dir/ffp.txt") {
      print "Creating ffp.txt\n";

      open (METAFLAC, "$EXES{metaflac} --show-md5sum " .
	    join (" ", map { quotemeta $_ } @FLACS) . "|")
	or die "Unable to open pipe from metaflac: $!\n";

      open (FFP, "> ffp.txt") or die "Unable to write ffp.txt: $!\n";

      print FFP "FLAC fingerprints generated by $progname $version at " .
	scalar (localtime) . "\n\n";

      while (<METAFLAC>) {
	 print FFP $_;
      }

      close METAFLAC;
      close FFP;
   }

   # Rename original MD5 files
   my @MD5S = $info->files ("md5");

   if (scalar @MD5S) {
      print "Renaming MD5 files:\n";

      foreach my $file (@MD5S) {
	 (my $newname = $dir . "/" . basename ($file)) =~ s/$/.orig/;
	 print "\t$file -> $newname\n";
	 if (not $dryrun) {
	    rename ($file, $newname)
	      or die "Rename failed: $!\n";
	 }
      }
   }

   # Remove empty subdirs
   if (not $dryrun) {
      print "Removing empty subdirs\n";
      local $File::Find::dont_use_nlink = 1;
      finddepth (sub { rmdir if -d }, $dir);
   }

   # Rename the directory to have a .flac16 extension
   (my $newdir = $dir) =~ s/\.(wav|shn|flac\d*)f?$//ig;
   $newdir .= ".flac16";

   if (not $dryrun and $newdir ne $dir) {
      print "Renaming $dir -> $newdir\n";
      chdir ("..") or die "Unable to chdir: $!\n";
      rename ($dir, $newdir) or die "Rename failed: $!\n";
   }

   print "\nDone processing $dir\n\n";

   1;
}

sub tag_files {
   my $info = shift;
   my $songs = shift;
   my $files = shift;

   # FLAC tags taken from
   # http://reactor-core.org/ogg-tag-recommendations.html
   my %VALUES;

   $VALUES{"ARTIST"} = $info->artist if $info->artist;
   $VALUES{"ALBUM"} = $info->album if $info->album;
   $VALUES{"DATE"} = $info->year if $info->year;
   $VALUES{"LOCATION"} = $info->venue if $info->venue;
   $VALUES{"SOURCEMEDIA"} = $info->source if $info->source;

   foreach my $index (0 .. $#$files) {
      my $song = ref ($songs) ? $songs->[$index] : undef;

      delete $VALUES{"DISCNUMBER"};
      delete $VALUES{"TRACKNUMBER"};
      delete $VALUES{"TITLE"};
      delete $VALUES{"COMMENT"};

      # If running in --discs mode, tag files with DISCNUMBER and
      # TRACKNUMBER.  Not all applications/devices honor the
      # DISCNUMBER tag though, so this may leave you with all of your
      # Track 1's sorting before all of your Track 2's.
      if (defined $song and $tagdiscs) {
	 $VALUES{"DISCNUMBER"} = $song->{Disc} if $song->{Disc};
	 $VALUES{"TRACKNUMBER"} = $song->{Track} || ($index + 1);
      } else {
	 $VALUES{"DISCNUMBER"} = undef;
	 $VALUES{"TRACKNUMBER"} = $index + 1;
      }

      $VALUES{"TITLE"} = $song->{Title} if defined $song and $song->{Title};

      my $note;
      $note = $song->{Notes} if defined $song and exists $song->{Notes};

      if (defined $note and exists $info->{Notes}{$note}) {
	 $VALUES{"COMMENT"} = $info->{Notes}{$note};
      } else {
	 $VALUES{"COMMENT"} = undef;
      }

      my %TAGS = %TAGFORMAT;

      foreach my $tag (keys %TAGS) {
	 my $format = $TAGS{$tag};
	 foreach my $key (keys %VALUES) {
	    my $value = $VALUES{$key} || "";
	    $format =~ s/\b$key\b/$value/g;
	 }
	 if (length $format and $format ne $TAGS{$tag}) {
	    $TAGS{$tag} = $format;
	 } else {
	    delete $TAGS{$tag};
	 }
      }

      print "" . sprintf ("%2d/%2d", $index + 1, $#$files + 1) . ": " .
	($TAGS{TITLE} || "") .
	  (exists $TAGS{COMMENT} ? " ($TAGS{COMMENT})" : "") . "\n";

      my @TAGS;
      foreach my $tag (keys %TAGS) {
	 push (@TAGS, "--remove-tag=$tag");
	 push (@TAGS, "--set-tag=$tag=$TAGS{$tag}")
	   if defined $TAGS{$tag};
      }
      my @CMD = ("metaflac", @TAGS, $files->[$index]);

      my $status = run_command (@CMD);

      if ($status != 0) {
	 warn "Error setting tags on $files->[$index]\n";
	 return 0;
      }
   }

   1;
}

sub replay_gain {
   my @FILES = @_;

   return 1 unless $replay_gain;

   if (not open (METAFLAC, "$EXES{metaflac} --list " .
		 "--block-type=VORBIS_COMMENT \Q$FILES[0]\E|")) {
      warn "Unable to read VORBIS_COMMENT block from $FILES[0] " .
	"to check for ReplayGain tags\n";
      return 0;
   }

   my $need = 1;

   while (<METAFLAC>) {
      $need = 0 if /REPLAYGAIN/;
   }

   close METAFLAC;

   return 1 unless $need;

   print "Adding ReplayGain information to FLACs (this may take a while)\n";

   my @CMD = ("metaflac", "--add-replay-gain", @FILES);

   my $status = run_command (@CMD);

   if ($status != 0) {
      warn "Error adding ReplayGain tags to FLAC files\n";
      return 0;
   }

   return 1;
}

# Operate on CWD if nothing is specified
if (not scalar @ARGV) { push (@ARGV, "."); }

foreach my $dir (map { File::Spec->rel2abs ($_) } @ARGV) {
   if (not -d $dir) {
      warn "$dir: not a directory\n";
      next;
   }

   my $info = new Etree::InfoFile (Directory => $dir,
				   Debug => $debug) or die;

   $info->parse;

   print "Processing directory $dir:\n\n";

   print "Etree::InfoFile dump:\n" . Dumper ($info) if $debug;

   print "Artist: ", $info->artist || "Unknown", "\n",
     "  Date: ", $info->date || "Unknown", "\n",
       " Venue: ", $info->venue || "Unknown", "\n",
	 "Source: ", $info->source || "Unknown", "\n",
	   "\n";

   # Get the list of all possible audio files we will convert
   my @FILES = sort { $a cmp $b } $info->files ("flac"),
     $info->files ("wav"), $info->files ("shn");

   if (not scalar @FILES) {
      print "No appropriate audio files found\n";
      next;
   }

   my @SONGS = $info->songs;

   if (scalar @SONGS and scalar @SONGS < scalar @FILES) {
      print "Number of songs from info file (" . scalar (@SONGS) .
	") doesn't match number of audio files (" . scalar (@FILES) . "):\n";
      print "Songs: ", join (", ", map { $_->{Title} } @SONGS), "\n",
	"Files: ", join (", ", map { basename $_ } @FILES), "\n";
      next;
   }

   print "Songs:\n", Dumper (\@SONGS) if $debug;

   # Truncate the song list to match the file list
   $#SONGS = $#FILES;

   convert_files ($info, \@SONGS, \@FILES) or die "Error converting files\n";
}

__END__

=head1 NAME

flacify - Convert audio files to FLAC files with Vorbis comments

=head1 SYNOPSIS

flacify [options] directory [directory ...]

=head1 OPTIONS

=over 4

=item B<--help>

Generate this usage message and exit.

=item B<--version>

Print version information and exit.

=item B<--debug>

Turn on debugging mode.  Dumps copious output useful mostly to the
maintainer.

=item B<--discs>

Keep tracks grouped by CD tracking boundaries and use the Ogg Vorbis
DISCNUMBER comment field to distinguish one disc from another.  Some
players do not honor this tag and so will sort track 1 of each disc
before track 2 of any disc (e.g. playback might run D1T1, D2T1, D1T2,
...).  The default is to number tracks sequentially from 1 to I<n>
with no regard to any disc groups.

=item B<--dry-run>

Print what commands would be run, but don't run them.

=item B<--noreplay-gain>

Disable the Replay Gain calculations when creating new FLAC files or
updating existing FLAC files.

=item B<--tag> B<TAG>=B<FORMAT>

Specify the formatting for the tags written to the FLAC files, or add
your own user-defined tags.  The default format for all of the
available tags is just themselves (e.g. DATE=DATE, COMMENT=COMMENT).
You can change the formatting by specifying something different.  For
exmaple, if you wanted the track title tags to include the date, you
could specify --tag "TITLE=DATE TITLE".  You could add your own tag to
all files by --tag MYTAG=MYVALUE.

See the section on L<Tagging> below for a list of all the standard
tags which are used by flacify.

=back

=head1 DESCRIPTION

The purpose of L<flacify> is to convert audio files from WAVE, Shorten
or FLAC format into losslessly-compressed, B<tagged> FLAC files.  The
code is geared towards processing live concert recordings arranged
according to the standards of L<http://etree.org/>.  The audio files
should be accompanied by a text file which provides detailed
information about the artist, date, venue and track list of the
recording.

For each directory the user specifies, L<flacify> performs the
following steps:

=over

=item Parsing

The directory is processed by the the L<Etree::InfoFile> module, which
searches for audio files and text files in the directory.  Text files
are parsed for the artist name, venue, date, song titles, recording
source, and other information.  These will be used in the tagging
process.

If no text files can be found, an error is emitted and the directory is
not processed.

If the input files are already FLAC files, we skip ahead to the
L<"Tagging"> step.

=item Decompression

Uncompressing any SHN files to WAV files using the L<unshn> script,
also from the etree-script distribution.  If the input consists of
only WAV files, this step is skipped.  FLAC files are not
decompressed either.

At the end of this step we are left will only WAV files.

=item Compression

Any WAV files resulting from the previous step are then compressed
using the command line L<flac> encoder.  The following options are
passed to L<flac>: C<--sector-align --delete-input-file --replay-gain>
The C<--reply-gain> option is omitted if the user passes the
--noreplay-gain argument to flacify.

=item Tagging

We are now left with all FLAC files.  These are tagged with the
information from the L<"Parsing"> step.  The tagging uses these fields
as specified by L<http://www.xiph.org/ogg/vorbis/doc/v-comment.html>:

=over

=item ARTIST

The performer.  Usually taken from the first line of the info file.

=item ALBUM

The date of the performance in YYYY-MM-DD format followed by the venue
information (e.g. "2003-01-01 Lupo's Hearbreak Hotel - Providence,
RI")

=item DATE

The year of the performance in YYYY format.

=item LOCATION

The venue where the performance happened.

=item SOURCEMEDIA

The recording source information, if this was found.  Usually contains
microphone, A/D converter, and recorder information.

=item DISCNUMBER

When run with B<--discs>, this tag will be set for each file.
Otherwise it will not be set.

=item TRACKNUMBER

The number of each track in the set.  When run with B<--discs>, the
TRACKNUMBER will be the number of the track within its disc, otherwise
it will be the number of the track in the entire set.

=item TITLE

The name of the song.

=item COMMENT

If there are any notes found for a given song, they will be included
in this tag.

=back

=item Directory Renaming

Finally, the directory is renamed to end in ".flac16".  If the
directory name previously ended in ".shn" or ".shnf", that suffix is
removed.

=back

=head1 VERSION

$Id$

=head1 SEE ALSO

L<unshn>, L<shorten>, L<flac>, L<metaflac>, L<Etree::InfoFile>

=head1 AUTHOR

Caleb Epstein E<lt>cae at bklyn dot orgE<gt>
