#!/usr/bin/perl -w
#
# md5check - recursively check md5sums on a directory tree.
#
# Requires the Digest::MD5 module.
#
# Author: Caleb Epstein <cae at bklyn dot org>
#
# $Id$

use strict;
use File::Find;
use File::Basename;

$File::Find::dont_use_nlink = 1;

eval "use Digest::MD5";
if ($@) {
   die <<EOF
You must install the Digest::MD5 Perl module for this script to work.  This
is available as the package "libdigest-md5-perl" on Debian/GNU Linux, or
on other systems you should be able to run:

    perl -MCPAN -eshell

and (after any configuration steps) type

  install Digest::MD5

Thanks, and sorry for the inconvenience.
EOF
  ;
}

my $progname = basename $0; $progname =~ s/\.pl$//;
my $checksum_regex = '\b[\da-f]{32}\b';
my %HAVE_SUMS;

# check_md5 - compute the MD5 digest of a file and compare it to a
# known-good digest string
sub check_md5 {
   my ($file, $sum) = @_;

   open (FILE, $file) or return 1;

   binmode FILE;		# In case we're on Windows

   my $md5 = Digest::MD5->new;
   my $hexdigest = $md5->addfile (*FILE)->hexdigest;

   close FILE;

   return ($hexdigest eq $sum) ? 0 : 1;
}

# check_ffp - extract the MD5 "fingerprint" from a FLAC file and
# compare it to a known-good digest string
sub check_ffp {
   my ($file, $sum) = @_;

   open (METAFLAC, "metaflac --show-md5sum \Q$file\E|") or return 1;
   my $hexdigest = <METAFLAC>;
   close METAFLAC;
   chomp $hexdigest;

   return ($hexdigest eq $sum) ? 0 : 1;
}

# parse_checksum_line - parse a line and split it into a checksum,
# filename, and a reference to the function we need to check the sum
sub parse_checksum_line {
   my $line = shift;
   my ($file, $checksum, $checker) = ("", undef, undef);

   if ($line =~ /^\s*(.+):($checksum_regex)\s*$/) {
      ($file, $checksum, $checker) = ($1, $2, \&check_ffp);
   } elsif ($line =~ /^\s*($checksum_regex)\s+\[shntool\]\s+(.+)\s*$/) {
      # For now just ignore shntool WAV data checksums
   } elsif ($line =~ /^\s*($checksum_regex)\s+\*?(.+)\s*$/) {
      ($file, $checksum, $checker) = ($2, $1, \&check_md5);
   }

   ($file, $checksum, $checker);
}

sub plural {
   my ($value, $string) = @_;
   "$value $string" . ($value != 1 ? "s" : "");
}

sub print_summary {
   my ($ok, $errors, $missing, $file) = @_;

   return unless $ok or $errors or $missing;

   $file ||= "Summary";
   my $status = ($errors ? "ERROR" : ($missing ? "WARNING" : "All OK"));
   my @SUMMARY;

   push (@SUMMARY, plural ($ok, "file") . " OK") if $ok;
   push (@SUMMARY, plural ($errors, "error")) if $errors;
   push (@SUMMARY, plural ($missing, "missing file")) if $missing;

   print "$file: $status: " . join (", ", @SUMMARY) . "\n";
}

# check_file - look for MD5 checksums in a file (FLAC "fingerprint"
# format or standard "md5sum" format) and check them.
sub check_file {
   my $sumfile = shift;
   my $dir = dirname $sumfile;
   my $base = basename $sumfile;
   my $status = 0;
   my $ok = 0;
   my $errors = 0;
   my $missing = 0;

   if (not open (MD5, $sumfile)) {
      warn "$progname: unable to open file $sumfile: $!\n";
      return (0, 1, 0);
   }

   my $data;

   # Slurp the entire file in one go
   {
      local $/ = undef;
      $data = <MD5>;
   }

   $data =~ s/\r/\n/g;

   # Split md5 data on newlines
   my @LINES = split /\n/, $data;

   # Pull out only lines that look like md5 lines (32 hex digits stand
   # by themselves), and turn them into (file, sum, checker) triplets
   my @SUMS = grep /$checksum_regex/, @LINES;
   chomp @SUMS;

   # Parse the line for filename, checksum, and functor; filter out
   # lines which look like checksums but which have an undef'd functor
   @SUMS = grep { defined $$_[2] }
     map { [ parse_checksum_line ($_) ] } @SUMS;

   # Sort by filename
   @SUMS = sort { $$a[0] cmp $$b[0] } @SUMS;

   return (0, 0, 0) unless scalar @SUMS;

   print "Checking $base (" . plural (scalar (@SUMS), "file") . "):\n";

   $| = 1;

   foreach (@SUMS) {
      my ($file, $sum, $func) = @{$_};
      my $fullfile = "$dir/$file";

      print " checking $file: ";

      # Before even calling the appropriate function, check for
      # existence and permissions to read
      if (not -e $fullfile) {
	 print "MISSING\n";
	 $status |= 2;
	 ++$missing;
	 next;
      } elsif (not -r $fullfile) {
	 print "PERMISSION DENIED\n";
	 $status |= 1;
	 ++$errors;
	 next;
      }

      # Run the checker
      my $result = &$func ($fullfile, $sum);

      if ($result == 0) {
	 print "OK\n";
	 ++$ok;
      } elsif ($result == 2) {
	 print "MISSING\n";
	 $status |= 2;
	 ++$missing;
      } else {
	 print "ERROR\n";
	 $status |= 1;
	 ++$errors;
      }
   }

   print_summary ($ok, $errors, $missing, $base);
   print "\n";

   return ($ok, $errors, $missing);
}

# Check a set of .flac files for consistency
sub check_flacfiles {
   my @FILES = @_;
   my $retval = 0;

   my @OK;
   my @FAILED;
   my $lastok = 0;
   my $lastfailed = 0;
   my $lastdir;
   my %NUMFILES;

   map { ++$NUMFILES{ dirname($_) } } @FILES;

   foreach my $file (@FILES) {
      my $base = basename $file;
      my $dir = dirname $file;

      if (not defined $lastdir or $lastdir ne $dir) {
	 if (defined $lastdir) {
	    print_summary (scalar (@OK) - $lastok,
			   scalar (@FAILED) - $lastfailed,
			   0, basename $lastdir);
	    print "\n";
	    $lastok = scalar @OK;
	    $lastfailed = scalar @FAILED;
	 }

	 print "Checking FLAC files in " . basename ($dir) . " (" .
	   plural ($NUMFILES{$dir}, "file") . "):\n";

	 $lastdir = $dir;
      }

      print " checking $base: ";

      my $retcode = system ("flac", "-t", "-s", $file);

      my $exit_value  = $retcode >> 8;
      my $signal_num  = $retcode & 127;
      my $dumped_core = $retcode & 128;

      if ($exit_value == 0 and not $signal_num and not $dumped_core) {
	 print "OK\n";
	 push (@OK, $file);
      } else {
	 warn "ERROR: FLAC exited" .
	   ($exit_value ? " with status $exit_value" : "") .
	     ($signal_num ? " from signal $signal_num" : "") .
	       ($dumped_core ? " (dumped core)" : "") . "\n";
	 # Stop processing if someone hits Ctrl-C
	 last if $signal_num == 2;
	 push (@FAILED, $file);
	 $retval |= 1;
      }
   }

   if (defined $lastdir) {
      print_summary (scalar (@OK) - $lastok,
		     scalar (@FAILED) - $lastfailed,
		     0, basename $lastdir);
      print "\n";
   }

   my $ok = scalar @OK;
   my $failed = scalar @FAILED;

   return ($ok, $failed, 0);
}

my %CHECKERS = ( '\.(ffp|md5|txt)$' => \&check_file,
		 '\.flac$' => [ \&check_flacfiles ]);

push (@ARGV, ".") unless scalar @ARGV;

my %TODO;

foreach my $arg (@ARGV) {
   sub wanted {
      return unless -f;
      my $file = $File::Find::name;
      foreach my $match (keys %CHECKERS) {
	 if ($file =~ /$match/i) {
	    push (@{$TODO{$match}}, $file);
	    last;
	 }
      }
   }
   find (\&wanted, $arg);
}

my ($ok, $errors, $missing) = (0, 0, 0);

foreach my $match (keys %TODO) {
   my $function = $CHECKERS{$match};
   my @FILES = sort @{$TODO{$match}};

   if (ref ($function) eq "ARRAY") {
      # Function can handle an array
      $function = $$function[0];
      my @A = &$function (@FILES);
      $ok += $A[0];
      $errors += $A[1];
      $missing += $A[2];
   } else {
      # Function takes one file at a time
      foreach my $file (@FILES) {
	 my @A = &$function ($file);
	 $ok += $A[0];
	 $errors += $A[1];
	 $missing += $A[2];
      }
   }
}

if ($ok or $errors or $missing) {
   print_summary ($ok, $errors, $missing);
}

exit (0 | ($errors ? 1 : 0) | ($missing ? 2 : 0));
